




    /* ***********************************
        Generate extra HTML to present the
        raw transcript text
        (switch language icon, audio play buttons etc.)
    ************************************** */



    function mainParser()
    {

        console.log("mainParser() BEGIN");


        // lookup all transcriptText if a subBlock divs is present make
        // sure the audio tag is moved to the bottom inside the subBlock div
        // if no subBlock div is present, still move the audio tag to the bottom
        // of the transcriptText div.
        // This is to make sure the audio tag is always at the bottom of the div

        let divsText = document.querySelectorAll('div.transcriptText');
        for (let i = 0; i < divsText.length; i++) {
            let divText = divsText[i];
            let subBlockDivs = divText.querySelectorAll('div.subBlock');
            if(subBlockDivs.length > 0)
            {
                for (let i = 0; i < subBlockDivs.length; i++)
                {
                    let div = subBlockDivs[i];
                    let audioTag = div.querySelector('audio');
                    // move the audio tag to the bottom of the div:
                    if(audioTag != null)
                        div.appendChild(audioTag);
                }
            } else {
                // move the audio tag to the bottom of the transcriptText div:
                let audioTag = divText.querySelector('audio');
                if(audioTag != null)
                    divText.appendChild(audioTag);
            }
        }










        // we look up all the divs with class 'transcriptText'
        // and wrap them as follows:
        // <div class="transcriptBox outer">
        // <div class="transcriptBox">
        //    <div class='header'>
        //        <!-- code for icon will be generated by JS -->
        //    </div>
        //    #ORIGINAL_DIV#
        //    <div class="transcriptText"></div>
        //    #ORIGINAL_DIV#
        // </div>
        // </div>

        let darkClass = ' dark';
        //let divsText = document.querySelectorAll('div.transcriptText');
        for (let i = 0; i < divsText.length; i++) {
            let divText = divsText[i];
            // save the placement of divText:
            let parent = divText.parentElement;

            // check if transcriptText has already been wrapped
            // by checking its parent element contains the class 'transcriptBox':
            if(divText.parentElement.classList.contains('transcriptBox'))
                continue;

                // check if transcriptText also contains the class 'no-header':
            let createHeader = !divText.classList.contains('no-header');


            // find the children element of divText:
            //for( child of divText.children)
            //    console.log(child.innerHTML);

            let outerDiv = document.createElement('div');
            outerDiv.className = 'transcriptBox outer'+ darkClass;

            let innerDiv = document.createElement('div');
            innerDiv.className = 'transcriptBox'+ darkClass;

            outerDiv.appendChild(innerDiv);

            // create the header div:
            if(createHeader){
                let headerDiv = document.createElement('div');
                headerDiv.className = 'header';
                innerDiv.appendChild(headerDiv);
            }
            // place the new outerDiv where divText is:
            parent.insertBefore(outerDiv, divText);
            // place divText inside our new wrapper:
            innerDiv.appendChild(divText);

            // insert a break line after outerDiv:
            let br = document.createElement('br');
            parent.insertBefore(br, outerDiv.nextSibling);

        }

        // Generate the icons for each transcriptBox:
        // get a list  of all divs with class 'header' inside .transcriptBox
        let divs = document.querySelectorAll('.transcriptBox div.header');
        // insert html code for the icons:
        // onmousedown="this.style["border-style"] = solid; this.style["border-width"] = 5px; this.style["border-color"] = white;"
        for (let i = 0; i < divs.length; i++) {
            divs[i].innerHTML = `
                <div class="icon_en_pos" onclick='toggleEnglish(this);' >
                    <a href='' onclick='return false;'>
                        <img class="icon_en" height="11" width="16" src="/images/starcraft_transcript/icons/gb.png"

                                onmouseover="this.style.opacity = 0.6;"
                                onmouseout="this.style.opacity = 1.0;"
                        >
                    </a>
                </div>

                <div class="icon_jp_pos" onclick='toggleJapanese(this);'>
                    <a href='' onclick='return false;'>
                        <img class="icon_jp" height="11" width="16" src="/images/starcraft_transcript/icons/jp.png"

                                onmouseover="this.style.opacity = 0.6;"
                                onmouseout="this.style.opacity = 1.0;"
                        >
                    </a>
                </div>

                <div class="icon_fr_pos" onclick='toggleFrench(this);'>
                    <a href='' onclick='return false;'>
                        <img class="icon_fr" height="11" width="16" src="/images/starcraft_transcript/icons/jp_plus.png"


                                onmouseover="this.style.opacity = 0.6;"
                                onmouseout="this.style.opacity = 1.0;"
                        >
                    </a>
                </div>
                `;
        }

        // onmousedown="this.classList.add('flag-highlighted')"
        // onmouseleave="this.classList.remove('flag-highlighted')"
        // onmouseup="this.classList.remove('flag-highlighted')"


        // Generate icons for the player:
        // look up all audio tags within .transcriptText:
        let audioElements = document.querySelectorAll('.transcriptText audio');
        for(audioTag of audioElements){

            // skip if has the controls attribute:
            if(audioTag.hasAttribute('controls')){
                // make it loop:
                audioTag.setAttribute('loop', '');
                continue;
            }

            // create a div after the audio tag:
            let div = document.createElement('div');
            div.innerHTML = `
                <img
                    src="/images/starcraft_transcript/player/control_play.png"
                    name="playbutton"
                    class="playbutton"
                    title="Play audio"
                    style="max-width:16px;"
                    onclick="play_nearest_audio(this.parentElement)"
                    onmouseover="this.src='/images/starcraft_transcript/player/control_play_blue.png'"
                    onmouseout="this.src='/images/starcraft_transcript/player/control_play.png'"
                    width="16px" height="16px"
                >

                <img
                    src="/images/starcraft_transcript/player/control_pause.png"
                    name="pausebutton"
                    class="pausebutton"
                    title="Pause"
                    style="display: none; max-width:16px;"
                    onclick="pausieren(this.parentElement)"
                    onmouseover="this.src='/images/starcraft_transcript/player/control_pause_blue.png'"
                    onmouseout="this.src='/images/starcraft_transcript/player/control_pause.png'"
                    width="16px" height="16px"
                >

                <img
                    src="/images/starcraft_transcript/player/control_stop.png"
                    name="resetbutton"
                    class="resetbutton"
                    title="Stop playing"
                    style="display: none; max-width:16px;"
                    onclick="resetTime(this.parentElement)"
                    onmouseover="this.src='/images/starcraft_transcript/player/control_stop_blue.png'"
                    onmouseout="this.src='/images/starcraft_transcript/player/control_stop.png'"
                    width="16" height="16"
                >
            `;
            // Insert it right after the audio tag:
            audioTag.parentElement.insertBefore(div, audioTag.nextSibling);
            //audioTag.parentElement.insertAfter(div);

        }





        {
            // Override <link rel="shortcut icon" href="http://rodolphe-vaillant.fr/images/favicon.png">
            // to use /images/sc.ico instead:
            let links = document.getElementsByTagName('link');
            for (let i = 0; i < links.length; i++) {
                if (links[i].getAttribute('rel') == 'shortcut icon') {
                    links[i].setAttribute('href', './images/starcraft_transcript/SC.ICO');
                }
            }
        }



        {
            /*
                look the various languages and generate missing ones.
            */

            // find all elements that contain a div.engish, div.japanese or div.french
            let divs = document.querySelectorAll('div.english, div.japanese, div.french');
            // create a unique set of parents:
            let parents = new Set();
            for (let i = 0; i < divs.length; i++) {
                parents.add(divs[i].parentElement);
            }

            for (let parent of parents) {
                let englishDiv  = parent.getElementsByClassName('english');
                let japaneseDiv = parent.getElementsByClassName('japanese');
                let frenchDiv   = parent.getElementsByClassName('french');

                if(englishDiv.length == 0) {
                    let div = document.createElement('div');
                    div.className = 'english';

                    if( japaneseDiv.length  > 0)
                        div.innerHTML = japaneseDiv[0].innerHTML + "<br>" + "(No english found)";
                    else if( frenchDiv.length  > 0)
                        div.innerHTML = frenchDiv[0].innerHTML + "<br>" + "(No english found)";
                    else
                        div.innerHTML = "(No english found)";

                    parent.appendChild(div);
                }

                if(japaneseDiv.length == 0) {
                    let div = document.createElement('div');
                    div.className = 'japanese';

                    if( englishDiv.length  > 0)
                        div.innerHTML = englishDiv[0].innerHTML + "<br>" + "(No  plain japanese found)";
                    else if( frenchDiv.length  > 0)
                        div.innerHTML = frenchDiv[0].innerHTML + "<br>" + "(No plain japanese found)";
                    else
                        div.innerHTML = "(No plain japanese found)";

                    parent.appendChild(div);
                }

                if(frenchDiv.length == 0) {
                    let div = document.createElement('div');
                    div.className = 'french';

                    if( japaneseDiv.length > 0)
                        div.innerHTML = japaneseDiv[0].innerHTML + "<br>" + "(No detailed japanese found)";
                    else if( englishDiv.length  > 0)
                        div.innerHTML = englishDiv[0].innerHTML + "<br>" + "(No detailed japanese found)";
                    else
                        div.innerHTML = "(No detailed japanese found)";

                    parent.appendChild(div);
                }
            }
        }


        if(true)
        {
            // detect if we have markdown like items syntax in the divs such has:
            //    - some text
            //    - some other text
            // and convert it to html
            // FIXME: handle multiple lines:
            //  - first line
            //    line return
            //  - next item
            //  - another item
            //  - last item
            //  line return should be included in last item
            //
            //  start of new paragraph.


            // find all elements that contain a div.engish, div.japanese or div.french
            let divs = document.querySelectorAll('div.english, div.japanese, div.french');

            // lookup divs:
            for (let i = 0; i < divs.length; i++)
            {
                let div = divs[i];
                let text = div.innerHTML;
                let lines = text.split('\n');
                let newLines = [];
                let itemBlocks = []; // array of array of items

                // check if we have a markdown like syntax:

                let j = 0;
                while( j < lines.length)
                {
                    lines[j];

                    // detect markdown blocks
                    // if the line starts with "- " (there may be spaces before the dash)
                    // we continue looping until we find a line that doesn't start with "- "
                    if( lines[j].match(/^\s*-\s/) )
                    {
                        newLines.push("#{MARKDOWN_ITEMS}#");
                        let items = [];
                        items.push(lines[j]);
                        j++;
                        while (lines[j].match(/^\s*-\s/)) {
                            items.push(lines[j]);
                            j++;
                        }
                        itemBlocks.push(items);
                    } else {
                        newLines.push(lines[j]);
                        j++;
                    }
                }

                // look up newlines for markdown items:
                for (let j = 0; j < newLines.length; j++) {
                    if (newLines[j] != "#{MARKDOWN_ITEMS}#")
                        continue;

                    // we found a markdown item block:
                    let items = itemBlocks.shift();
                    let html = "<ul>";
                    for (let k = 0; k < items.length; k++) {
                        html += "<li>" + items[k].replace(/^\s*-\s/, '') + "</li>";
                    }
                    html += "</ul>";
                    newLines[j] = html;
                }

                // replace the div content:
                div.innerHTML = newLines.join('\n');
            }// end for divs
        }

        {
            // ruby syntax conversion for furigana.
            // detect if we use syntax like:
            //      regular space + some_kanji + [ + furigana + ]
            // and convert it to ruby syntax:
            //    <ruby>some_kanji<rt>furigana</rt></ruby>


            // find all elements that contain a div.french
            let divs = document.querySelectorAll('div.french');
            for (let i = 0; i < divs.length; i++) {
                let div = divs[i];
                let text = div.innerHTML;
                let lines = text.split('\n');
                let newLines = [];
                for (let j = 0; j < lines.length; j++) {
                    let line = lines[j];
                    let newLine = line.replace(/ ([一-龯,ぁ-ん,0-9,０-９,々]+)\[([ぁ-んァ-ン]+)\]/g, "<ruby>$1<rt>$2</rt></ruby>");
                    newLines.push(newLine);
                }
                div.innerHTML = newLines.join('\n');
            }
        }


        if(true){
            // find all tags <narrator> </narrator>

            let narrators = document.querySelectorAll('narrator');
            // each div will be replaced by a <h3> tag:
            for (let i = 0; i < narrators.length; i++) {
                let div = narrators[i];
                let parent = narrators[i].parentElement;
                let englishDiv  = parent.getElementsByClassName('english');
                let japaneseDiv = parent.getElementsByClassName('japanese');
                let frenchDiv   = parent.getElementsByClassName('french');


                let englishHeader = document.createElement('h3');
                let frenchHeader = document.createElement('h3');
                let JapaneseHeader = document.createElement('h3');

                let japText = div.innerHTML;
                englishHeader.innerHTML = div.innerHTML;

                if( div.innerHTML in narrator_dict)
                    japText = narrator_dict[div.innerHTML].jap;
                else
                    console.log("Error: can't find narrator:"+div.innerHTML);

                frenchHeader.innerHTML = japText;
                JapaneseHeader.innerHTML = japText;

                // inserts englishHeader at the top of englishDiv:
                if(englishDiv.length > 0)
                    englishDiv[0].insertBefore(englishHeader, englishDiv[0].firstChild);

                // inserts frenchHeader at the top of frenchDiv
                if(frenchDiv.length > 0)
                    frenchDiv[0].insertBefore(frenchHeader, frenchDiv[0].firstChild);

                // inserts japaneseHeader at the top of japaneseDiv
                if(japaneseDiv.length > 0)
                    japaneseDiv[0].insertBefore(JapaneseHeader, japaneseDiv[0].firstChild);
            }

            // remove all narrator tags from the document:
            narrators.forEach(narrator => narrator.parentNode.removeChild(narrator));
        }



        if(false)
        {
            // find all tags <narrator> and convert them to a <h3> tag/narrator:
            let divs = document.querySelectorAll('narrator');
            // each div will be replaced by a <h3> tag:
            for (let i = 0; i < divs.length; i++) {
                let div = divs[i];
                let text = div.innerHTML;
                let newLine = "<h3>" + text + "</h3>";
                div.outerHTML = newLine;

            }


        }

        {
            // Set all text to japanese by default:
            // query all div.header inside a .transcriptBox:
            let divs = document.querySelectorAll('.transcriptBox div.header');
            for (let i = 0; i < divs.length; i++) {
                toggleJapanese(divs[i]);
                //toggleFrench(divs[i]);
            }
        }

        console.log("mainParser() FINISHED");

    }


    function fixSrcPaths(div, filePath) {
        // get the directory path of filePath
        // (remove the file name /xxx.html):
        let dirPath = filePath.replace(/\/[^\/]*$/, '/'); // replace /xxx.html with /

        // replace all src="./localPath" with src="dirPath/localPath"
        let imgs = div.getElementsByTagName('img');
        let source = div.getElementsByTagName('source');
        let elements = [...imgs, ...source];

        for (let i = 0; i < elements.length; i++) {
            let elt = elements[i];
            let src = elt.getAttribute('src');
            if (src == null)
                continue;
            elt.setAttribute('src', dirPath + src);
        }
    }

    function insertContent(i, content)
    {
            let filePath = i.getAttribute('src');
            if (false) {
                i.insertAdjacentHTML('afterend', content);
            } else {

                let div = document.createElement('div');
                div.innerHTML = content;
                // insert it after the include tag:
                i.insertAdjacentElement('afterend', div);
                // add "name" attribute to div so we can find it back:
                div.setAttribute('name', filePath);
                fixSrcPaths(div, filePath);
                console.log("includeHtmlFiles() -- then(  content ) ");
            }
            i.remove();
    }


    // ultimately this should really be a smarty extension:
    // look for smarty tags to do includes.
    function includeHtmlFiles()
    {
        // parse for:
        // <include src="a.html">Loading...</include>
        // and replace with the content of a.html


        const includes = document.getElementsByTagName('include');

        if(true)
        {
            // Sequential loading of the files:
            //let promise1 = new Promise((resolve, reject) => { resolve(value); });
            let promise = Promise.resolve();
            // equivalent to the above: let promise = Promise.resolve();
            for(let i=0; i<includes.length; i++)
            {

                let elt = includes[i];

                let filePath = elt.getAttribute('src');
                promise = promise.then(
					() => fetch(filePath)
				)
                .catch(
					() => console.log("error loading: " + filePath)
				);
                promise = promise.then(file => file.text() );

                promise = promise.then( content =>
                {
                    //insertContent(elt, content);
                    //return undefined;

                    return new Promise((resolve, reject) => {
                        insertContent(elt, content);
                        resolve();
                    });
                }
                );
            }
            return promise;
        }
        else
        {

            // this works:
            // and should work in parallel:
            let promises = [];
            for(let i=0; i<includes.length; i++)
            {

                let elt = includes[i];

                let filePath = elt.getAttribute('src');

                let p = fetch(filePath)
                        .then(file => file.text() )
                        .then( content =>
                            new Promise((resolve, reject) => {
                                insertContent(elt, content);
                                resolve();
                            })
                        );

                promises.push(p);
            }
            return new Promise((resolve, reject) => {
                Promise.all(promises).then( () => resolve() );
            });
        }


        // Next challenge: is to use await / async in both sequential and parallel scenarios...
        // But first test the above more thoroughly...


    }


    // maybe I'll use a smarty extension to generate this code,
    // for now I use javascript:
    // when pages loads:
    document.addEventListener("DOMContentLoaded", function (event)
    {

        // insert the <include></include> tags at
        // <div id="insert-content-here"></div> :
        {
            let insertContentHere = document.getElementById('insert-content-here');

            terran_files.forEach( (filePath) => {
                let includeTag = document.createElement('include');
                includeTag.setAttribute('src', filePath);
                includeTag.innerHTML = "Loading...";
                insertContentHere.appendChild(includeTag);
            });
        }

        // Replace the <include> tags with the content of the file:
        let waitOnIncludesProcessing = includeHtmlFiles();

        // Further processing the generated content:
        waitOnIncludesProcessing.then( () => {
            mainParser();
        });

    });